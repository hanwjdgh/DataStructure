# C++ STL

## 1. C++ 표준 템플릿 라이브러리 (Standard Template Library - STL)

C++ 템플릿 라이브러리(STL):

- 임의 타입의 객체를 보관할 수 있는 컨테이너 (container)
- 컨테이너에 보관된 원소에 접근할 수 있는 반복자 (iterator)
- 반복자들을 가지고 일련의 작업을 수행하는 알고리즘 (algorithm)

## 2. C++ STL 컨테이너 - 벡터 (std::vector)

C++ STL 컨테이너:

- 시퀀스 컨테이너 (sequence container) : vector, list, deque
- 연관 컨테이너 (associative container) : set, map

vector의 복잡도:

- 임의의 위치 원소 접근 ([], at) : ㄴO(1)
- 맨 뒤에 원소 추가 및 제거 (push_back/pop_back) : amortized O(1); (평균적으로 O(1) 이지만 최악의 경우 O(n) )
- 임의의 위치 원소 추가 및 제거 (insert, erase) : O(n)

## 3. 반복자 (iterator)

반복자는 컨테이너에 원소에 접근할 수 있는 포인터와 같은 객체, 반복자는 컨테이너에 iterator 멤버 타입으로 정의되어 있다.

~~~C++
#include <iostream>
#include <vector>


template <typename T>
void print_vector(std::vector<T>& vec) {
    // 전체 벡터를 출력하기
    for (typename std::vector<T>::iterator itr = vec.begin(); itr != vec.end(); ++itr)
        std::cout << *itr << std::endl;
}

int main() {
    std::vector<int> vec;
    vec.push_back(10);
    vec.push_back(20);
    vec.push_back(30);
    vec.push_back(40);

    std::cout << "처음 벡터 상태" << std::endl;
    print_vector(vec);
    std::cout << "----------------------------" << std::endl; // 10 20 30 40

     std::cout << "역으로 vec 출력하기!" << std::endl;
    // itr 은 vec[2] 를 가리킨다.
    std::vector<int>::reverse_iterator r_iter = vec.rbegin();
    for (; r_iter != vec.rend(); r_iter++)
      std::cout << *r_iter << std::endl; // 40 30 20 10

    // vec[2] 앞에 15 추가
    vec.insert(vec.begin() + 2, 15);
    print_vector(vec);  // 10 20 15 30 40

    std::cout << "----------------------------" << std::endl;
    // vec[3] 제거
    vec.erase(vec.begin() + 3);
    print_vector(vec); // 10 20 15 40

    /*
    컨테이너에 원소를 추가하거나 제거하게 되면 기존에 사용하였던 모든 반복자들을 사용할 수 없게된다.
    */

    // itr 은 vec[2] 를 가리킨다.
    std::vector<int>::iterator itr = vec.begin() + 2;

    // vec[2] 의 값을 50으로 바꾼다.
    *itr = 50;

    std::cout << "---------------" << std::endl;
    print_vector(vec); // 10 20 50 40

    std::vector<int>::const_iterator citr = vec.cbegin() + 2;

    // 상수 반복자가 가리키는 값은 바꿀수 없다. 불가능!
    //*citr = 30;
}
~~~

## 4. 범위 기반 for문 (range based for loop)

for (/* 원소를 받는 변수 정의 */ : /* 컨테이너 */) { }

~~~C++
#include <iostream>
#include <vector>


template <typename T>
void print_vector_range_based(std::vector<T>& vec) {
    // 전체 벡터를 출력하기
    /*
    const auto& 대신 int 를 상용하면 elem = vec[i]; 처럼 복사가 진행된다.
    const auto& 를 사용하면 elem 은 vec 의 원소들을 상수 레퍼런스
    */
    for (const auto& elem : vec)
        std::cout << elem << std::endl;
}

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    vec.push_back(4);

    std::cout << "print_vector_range_based" << std::endl;
    print_vector_range_based(vec);

    return 0;
}
~~~

## 5. 리스트 (list)

리스트(list) 의 경우 양방향 연결 구조를 가진 자료형,  vector 와는 달리 임의의 위치에 있는 원소에 접근을 바로 할 수 없다.

vector 의 경우 맨 뒤를 제외하고는 임의의 위치에 원소를 추가하거나 제거하는 작업이 O(n) 이였지만 리스트의 경우 O(1) 으로 매우 빠르게 수행될 수 있다.

리스트의 반복자의 경우 다음과 같은 연산밖에 수행할 수 없습니다.

~~~C++
itr++    // itr ++
itr--  // --itr 도 됩니다.

itr + 5  // 불가능!
~~~

리스트 에서 정의되는 반복자의 타입을 보면 BidirectionalIterator 타입, 벡터에서 정의되는 반복자의 타입은 RandomAccessIterator 타입

~~~C++
#include <iostream>
#include <list>

template <typename T>
void print_list(std::list<T>& lst) {
    std::cout << "[ ";
    // 전체 리스트를 출력하기 (이 역시 범위 기반 for 문을 쓸 수 있습니다)
    for (const auto& elem : lst)
        std::cout << elem << " ";
    std::cout << "]" << std::endl;
}

int main() {
    std::list<int> lst;

    lst.push_back(10);
    lst.push_back(20);
    lst.push_back(30);
    lst.push_back(40);

    std::cout << "처음 리스트의 상태 " << std::endl;
    print_list(lst); // 10 20 30 40

    for (std::list<int>::iterator itr = lst.begin(); itr != lst.end(); ++itr) {
        // 만일 현재 원소가 20 이라면
        // 그 앞에 50 을 집어넣는다.
        if (*itr == 20)
            lst.insert(itr, 50);
    }

    std::cout << "값이 20 인 원소 앞에 50 을 추가 " << std::endl;
    print_list(lst); // 10 50 20 30 40

    for (std::list<int>::iterator itr = lst.begin(); itr != lst.end(); ++itr) {
        // 값이 30 인 원소를 삭제한다.
        if (*itr == 30) {
            lst.erase(itr);
            break;
        }
    }

    std::cout << "값이 30 인 원소를 제거한다" << std::endl;
    print_list(lst); // 10 50 20 40
}
~~~

리스트의 경우는 벡터와는 다르게, 원소를 지워도 반복자가 무효화 되지 않습니다. 왜냐하면, 각 원소들의 주소값들은 바뀌지 않기 때문이다.

## 6. 덱 (deque - double ended queue)

덱은 벡터와 비슷하게 O(1) 으로 임의의 위치의 원소에 접근할 수 있으며 맨 뒤에 원소를 추가/제거 하는 작업도 O(1) 으로 수행할 수 있다. 뿐만아니라 벡터와는 다르게 맨 앞에 원소를 추가/제거 하는 작업 까지도 O(1) 으로 수행 가능하다.

임의의 위치에 있는 원소를 제거/추가 하는 작업은 벡터와 마찬가지로 O(n) 으로 수행 가능하다. 뿐만 아니라 그 속도도 벡터 보다 더 빠르다.

덱의 경우 원소들이 실제로 메모리 상에서 연속적으로 존재하지는 않는다. 이 때문에 원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리가 더 필요로 한다. (실제 예로, 64 비트 libc++ 라이브러리의 경우 1 개의 원소를 보관하는 덱은 그 원소 크기에 비해 8 배나 더 많은 메모리를 필요하다).

즉, 덱은 실행 속도를 위해 메모리를 (많이) 희생하는 컨테이너이다.

~~~C++
#include <deque>
#include <iostream>

template <typename T>
void print_deque(std::deque<T>& dq) {
    // 전체 덱을 출력하기
    std::cout << "[ ";
    for (const auto& elem : dq)
      std::cout << elem << " ";
    std::cout << " ] " << std::endl;
}
int main() {
    std::deque<int> dq;
    dq.push_back(10);
    dq.push_back(20);
    dq.push_front(30);
    dq.push_front(40);

    std::cout << "초기 dq 상태" << std::endl;
    print_deque(dq); // 40 30 10 20

    std::cout << "맨 앞의 원소 제거" << std::endl;
    dq.pop_front();
    print_deque(dq); // 30 10 20
}
~~~

[] 와 at 함수를 제공하고 있고, 반복자 역시 RandomAccessIterator 타입 이고 벡터랑 정확히 동일한 방식으로 작동한다.

- 일반적인 상황에서는 그냥 벡터를 사용 (거의 만능)
- 만약에 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 일을 많이 하고, 원소들을 순차적으로만 접근 한다면 리스트를 사용
- 만약에 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이하면 덱을 사용

## 7. 셋 (set)

원소를 추가하기 위해서는 시퀀스 컨테이너 처럼 insert 함수를 사용, 한 가지 다른점은, 시퀀스 컨테이너 처럼 '어디에' 추가할지에 대한 정보가 없다는 점

- 셋에 원소를 추가하거나 지우는 작업은 O(log N) 에 처리
- 반복자는 BidirectionalIterator
- 셋의 경우 내부에 원소를 추가할 때 정렬된 상태를 유지하며 추가

셋에는 find 함수가 제공, 이 find 함수를 통해 이 셋에 원소가 존재하는지 아닌지 확인가능, 해당하는 원소가 존재한다면 이를 가리키는 반복자를 리턴하고 (std::set<>::iterator 타입) 만일 존재하지 않는다면 s.end() 를 리턴, O(logN)

- 내부적으로 BST (Binary Serach Tree) 구조
- 셋 안에는 중복된 원소들이 없다

~~~C++
#include <iostream>
#include <set>

template <typename T>
void print_set(std::set<T>& s) {
    // 셋의 모든 원소들을 출력하기
    std::cout << "[ ";
    for (typename std::set<T>::iterator itr = s.begin(); itr != s.end(); ++itr)
        std::cout << *itr << " ";

    /*
    for (const auto& elem : s) {
        std::cout << elem << " ";
    }
    */

    std::cout << " ] " << std::endl;
}
int main() {
    std::set<int> s;
    s.insert(10);
    s.insert(50);
    s.insert(20);
    s.insert(40);
    s.insert(30);

    std::cout << "순서대로 정렬되서 나온다" << std::endl;
    print_set(s); // 10 20 30 40 50

    std::cout << "20 이 s 의 원소인가요? :: "; // YES
    auto itr = s.find(20);
    if (itr != s.end()) {
        std::cout << "Yes" << std::endl;
    } else {
        std::cout << "No" << std::endl;
    }

    std::cout << "25 가 s 의 원소인가요? :: "; // NO
    itr = s.find(25);
    if (itr != s.end()) {
        std::cout << "Yes" << std::endl;
    } else {
        std::cout << "No" << std::endl;
    }
}  
~~~

### 클래스 객체를 셋에 넣고 싶을 때

operator< 함수를 만들어서 원소간의 크기를 정의 해주어야 한다.

~~~C++
#include <iostream>
#include <set>
#include <string>

// 1. operator< 를 사용 할 경우

template <typename T>
void print_set(std::set<T>& s) {
    // 셋의 모든 원소들을 출력하기
    for (const auto& elem : s) {
        std::cout << elem << " " << std::endl;
    }
}

class Todo {
    int priority;
    std::string job_desc;

    public:
        Todo(int priority, std::string job_desc) : priority(priority), job_desc(job_desc) {}

        // 셋 내부적으로 정렬 시에 상수 반복자를 사용하기 때문에 const 함수 사용
        bool operator<(const Todo& t) const {
            if (priority == t.priority) {
                return job_desc < t.job_desc;
            }
            return priority > t.priority;
        }

    friend std::ostream& operator<<(std::ostream& o, const Todo& td);
};

// 2. operator< 를 사용 안 할 경우

template <typename T, typename C>
void print_set(std::set<T, C>& s) {
    // 셋의 모든 원소들을 출력하기
    for (const auto& elem : s) {
        std::cout << elem << " " << std::endl;
    }
}

class Todo {
    int priority;
    std::string job_desc;

    public:
        Todo(int priority, std::string job_desc) : priority(priority), job_desc(job_desc) {}

        friend struct TodoCmp;
        friend std::ostream& operator<<(std::ostream& o, const Todo& td);
};

struct TodoCmp {
    bool operator()(const Todo& t1, const Todo& t2) const {
        if (t1.priority == t2.priority) {
            return t1.job_desc < t2.job_desc;
        }
        return t1.priority > t2.priority;
    }
};


std::ostream& operator<<(std::ostream& o, const Todo& td) {
    o << "[ 중요도: " << td.priority << "] " << td.job_desc;
    return o;
}

int main() {
    std::set<Todo> todos;
    // 2번의 경우 std::set<Todo, TodoCmp> todos;

    todos.insert(Todo(1, "농구 하기"));
    todos.insert(Todo(2, "수학 숙제 하기"));
    todos.insert(Todo(1, "프로그래밍 프로젝트"));
    todos.insert(Todo(3, "친구 만나기"));
    todos.insert(Todo(2, "영화 보기"));

    print_set(todos);

    /*
    [ 중요도: 3] 친구 만나기
    [ 중요도: 2] 수학 숙제 하기
    [ 중요도: 2] 영화 보기
    [ 중요도: 1] 농구 하기
    [ 중요도: 1] 프로그래밍 프로젝트
    */

    std::cout << "-------------" << std::endl;
    std::cout << "숙제를 끝냈다면!" << std::endl;
    todos.erase(todos.find(Todo(2, "수학 숙제 하기")));
    print_set(todos);

    /*
    [ 중요도: 3] 친구 만나기
    [ 중요도: 2] 영화 보기
    [ 중요도: 1] 농구 하기
    [ 중요도: 1] 프로그래밍 프로젝트
    */
}
~~~

## 8. 맵 (map)

맵은 셋과 거의 똑같은 자료 구조 이다. 다만 셋의 경우 키만 보관했지만, 맵의 경우 키에 대응되는 값(value) 까지도 같이 보관
맵 역시 셋 처럼 중복된 원소를 허락하지 않는다.

~~~C++
#include <iostream>
#include <map>
#include <string>

template <typename K, typename V>
void print_map(std::map<K, V>& m) {
    // 맵의 모든 원소들을 출력하기
    for (auto itr = m.begin(); itr != m.end(); ++itr) {
        std::cout << itr->first << " " << itr->second << std::endl;
    }

    /*
    for (const auto& kv : m) {
        std::cout << kv.first << " " << kv.second << std::endl;
    }
    */
}

template <typename K, typename V>
void search_and_print(std::map<K, V>& m, K key) {
    auto itr = m.find(key);
    if (itr != m.end()) {
        std::cout << key << " --> " << itr->second << std::endl;
    } else {
        std::cout << key << "은(는) 목록에 없습니다" << std::endl;
    }
}

int main() {
    std::map<std::string, double> pitcher_list;

    /*
    std::pair
    template <class T1, class T2>
    struct std::pair {
        T1 first;
        T2 second;
    };
    */

    // 맵의 insert 함수는 pair 객체를 인자로 받습니다.
    pitcher_list.insert(std::pair<std::string, double>("박세웅", 2.23));

    // 타입을 지정하지 않아도 간단히 std::make_pair 함수로
    // std::pair 객체를 만들 수 도 있습니다.
    pitcher_list.insert(std::make_pair("차우찬", 3.04));

    // 혹은 insert 를 안쓰더라도 [] 로 바로
    // 원소를 추가할 수 있습니다.
    pitcher_list["니퍼트"] = 3.56;

    print_map(pitcher_list);

    /*
    니퍼트 3.56
    박세웅 2.23
    차우찬 3.04
    */

    std::cout << "류현진 방어율은? :: " << pitcher_list["류현진"] << std::endl; // 0
    // 맵에 없는 키를 참조하게 되면, 자동으로 값의 디폴트 생성자를 호출해서 원소를 추가해 버린다.
    // ->  find 함수로 원소가 키가 존재하는지 먼저 확인 후에, 값을 참조하는 것이 좋다.

    search_and_print(pitcher_list, std::string("류현진"));
}
~~~

## 9. 멀티셋(multiset)과 멀티맵(multimap)

### 멀티셋(multiset)

~~~C++
#include <iostream>
#include <set>
#include <string>

template <typename K>
void print_set(const std::multiset<K>& s) {
    // 셋의 모든 원소들을 출력하기
    for (const auto& elem : s) {
        std::cout << elem << std::endl;
    }
}

int main() {
    std::multiset<std::string> s;

    s.insert("a");
    s.insert("b");
    s.insert("a");
    s.insert("c");
    s.insert("d");
    s.insert("c");

    print_set(s); // a a b c c d
}
~~~

### 멀티맵(multimap)

~~~C++
#include <iostream>
#include <map>
#include <string>

template <typename K, typename V>
void print_map(const std::multimap<K, V>& m) {
    // 맵의 모든 원소들을 출력하기
    for (const auto& kv : m) {
        std::cout << kv.first << " " << kv.second << std::endl;
    }
}

int main() {
    std::multimap<int, std::string> m;

    m.insert(std::make_pair(1, "hello"));
    m.insert(std::make_pair(1, "hi"));
    m.insert(std::make_pair(1, "ahihi"));
    m.insert(std::make_pair(2, "bye"));
    m.insert(std::make_pair(2, "baba"));

    print_map(m);

    std::cout << "--------------------" << std::endl;

    // 1 을 키로 가지는 반복자들의 시작과 끝을
    // std::pair 로 만들어서 리턴한다.
    auto range = m.equal_range(1);
    for (auto itr = range.first; itr != range.second; ++itr) {
      std::cout << itr->first << " : " << itr->second << " " << std::endl;
    }

    /*
    1 : hello
    1 : hi
    1 : ahihi
    */
}
~~~

### 10. 정렬되지 않은 셋과 맵 (unordered_set, unordered_map)

원소들이 순서대로 정렬되서 들어가지 않는다. 따라서 반복자로 원소들을 하나씩 출력해보면 거의 랜덤한 순서로 나오는 것을 볼 수 있다.

insert, erase, find 모두가 O(1)O(1) 으로 수행된다.

원소를 삽입하거나 검색 하기 위해 먼저 해시 함수라는 것을 사용한다 (사실 그래서 원래 hashset 이나 hashmap 이란 이름을 붙이려고 했지만 이미 이러한 이름을 너무 많이 사용하고 있어서 충돌을 피하기 위해 저런 이름을 골랐다고 한다).

평균적으로 O(1) 시간으로 원소의 삽입/탐색을 수행할 수 있지만 최악의 경우 O(N) 으로 수행될 수 있다. (그냥 set 과 map 의 경우 평균도 O(log N) 최악의 경우에도 O(log N) 으로 실행된다)

해시충돌 : 서로 다른 원소가 같은 해시 함수값을 가져가 같은 상자에 들어가는 경우

처음부터 많은 개수의 상자를 사용할 수 없기 때문에 (메모리를 낭비할 순 없으므로..) 상자의 개수는 삽입되는 원소가 많아짐에 따라 점진적으로 늘어나게 된다. 문제는 상자의 개수가 늘어나면 해시 함수를 바꿔야 하기 때문에 (더 많은 값들을 해시값으로 반환할 수 있도록) 모든 원소들을 처음부터 끝 까지 다시 insert 해야 한다. 이를 rehash 라 하며 O(N) 만큼의 시간이 걸린다.

~~~C++
#include <iostream>
#include <string>
#include <unordered_set>

template <typename K>
void print_unordered_set(const std::unordered_set<K>& m) {
    // 셋의 모든 원소들을 출력하기
    for (const auto& elem : m) {
        std::cout << elem << std::endl;
    }
}

template <typename K>
void is_exist(std::unordered_set<K>& s, K key) {
    auto itr = s.find(key);
    if (itr != s.end()) {
        std::cout << key << " 가 존재!" << std::endl;
    } else {
        std::cout << key << " 가 없다" << std::endl;
    }
}

int main() {
    std::unordered_set<std::string> s;

    s.insert("hi");
    s.insert("to");
    s.insert("c++");

    print_unordered_set(s);
    std::cout << "----------------" << std::endl;
    is_exist(s, std::string("c++"));
    is_exist(s, std::string("c"));

    std::cout << "----------------" << std::endl;
    std::cout << "'hi' 를 삭제" << std::endl;
    s.erase(s.find("hi"));
    is_exist(s, std::string("hi"));
}
~~~

### 클래스를 unordered_set/unordered_map 의 원소로 넣고 싶을 때

먼저 내 클래스의 객체를 위한 '해시 함수'를 직접 만들어줘야 하기 때문에 셋이나 맵에 넣는것 보다 훨씬 어렵다.

이나 맵 과는 다르게 순서대로 정렬하지 않기 때문에 operator< 는 필요하지 않다. 하지만 해시 충돌 발생 시에 상자안에 있는 원소들과 비교를 해야하기 때문에 operator== 는 필요하다.

~~~C++
#include <functional>
#include <iostream>
#include <string>
#include <unordered_set>

template <typename K>
void print_unordered_set(const std::unordered_set<K>& m) {
    // 셋의 모든 원소들을 출력하기
    for (const auto& elem : m) {
        std::cout << elem << std::endl;
    }
}

template <typename K>
void is_exist(std::unordered_set<K>& s, K key) {
    auto itr = s.find(key);
    if (itr != s.end()) {
        std::cout << key << " 가 존재!" << std::endl;
    } else {
        std::cout << key << " 가 없다" << std::endl;
    }
}

class Todo {
    int priority;  // 중요도. 높을 수록 급한것!
    std::string job_desc;

    public:
        Todo(int priority, std::string job_desc) : priority(priority), job_desc(job_desc) {}

    bool operator==(const Todo& t) const {
        if (priority == t.priority && job_desc == t.job_desc) return true;
        return false;
    }

    friend std::ostream& operator<<(std::ostream& o, const Todo& t);
    friend struct std::hash<Todo>;
};

// Todo 해시 함수를 위한 함수객체(Functor) 를 만들어줍니다!
// namespace 안에 새로운 클래스/함수를 추가하기 위해서는 위처럼 명시적으로 namespace (이름) 를 써줘야만 한다.
namespace std {
template <>
struct hash<Todo> {
    // size_t 타입은 int 랑 동일한데, 이 말은 해시값으로 0 부터 4294967295 까지 가능하다는 뜻
    size_t operator()(const Todo& t) const {
        hash<string> hash_func;

        return t.priority ^ (hash_func(t.job_desc));
    }
};
}  // namespace std

std::ostream& operator<<(std::ostream& o, const Todo& t) {
    o << "[중요도 : " << t.priority << " ] " << t.job_desc;
    return o;
}

int main() {
    std::unordered_set<Todo> todos    ;

    todos.insert(Todo(1, "농구 하기"));
    todos.insert(Todo(2, "수학 숙제 하기"));
    todos.insert(Todo(1, "프로그래밍 프로젝트"));
    todos.insert(Todo(3, "친구 만나기"));
    todos.insert(Todo(2, "영화 보기"));
    print_unordered_set(todos);
    std::cout << "----------------" << std::endl;

    /*
    [중요도 : 2 ] 영화 보기
    [중요도 : 1 ] 프로그래밍 프로젝트
    [중요도 : 3 ] 친구 만나기
    [중요도 : 1 ] 농구 하기
    [중요도 : 2 ] 수학 숙제 하기
    */
}
~~~

- 데이터의 존재 유무 만 궁금할 경우 → set
- 중복 데이터를 허락할 경우 → multiset (insert, erase, find 모두 O(logN). 최악의 경우에도 O(logN))
- 데이터에 대응되는 데이터를 저장하고 싶은 경우 → map
- 중복 키를 허락할 경우 → multimap (insert, erase, find 모두 O(logN). 최악의 경우에도 O(logN))
- 속도가 매우매우 중요해서 최적화를 해야하는 경우 → unordered_set, unordered_map
(insert, erase, find 모두 O(1). 최악의 경우엔 O(N) 그러므로 해시함수와 상자 개수를 잘 설정해야 한다!)
